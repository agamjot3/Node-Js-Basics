"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const aws_sdk_1 = require("aws-sdk");
const environment_1 = require("./environment");
const lodash_1 = require("lodash");
const wait_promise_1 = require("wait-promise");
const archive_1 = require("./archive");
const debug = require('debug')('eb:application');
class Application {
    constructor(credentials = undefined) {
        // AWS Services
        this.s3 = new aws_sdk_1.S3(credentials);
        this.elasticbeanstalk = new aws_sdk_1.ElasticBeanstalk(credentials);
        this.environment = new environment_1.Environment(this.elasticbeanstalk);
        this.archive = new archive_1.Archive(this, this.s3);
    }
    /**
     * @param filePath - The path of archive to deploy (e.g. AppName-version.zip)
     * @param environmentName - Environment to provision (e.g. my-awesome-app)
     * @param stack - Stack to provision (e.g. '64bit Amazon Linux 2015.03 v2.0.0 running Node.js')
     * @param config - Configuration overrides for the environment (optional)
     * @param versionLabel - Optional version label
     * @param applicationName - The application name
     * @param tags - This specifies the tags applied to resources in the environment. (optional)
     * @param tier - This specifies the tier ie WebServer (default) or Worker. (optional)
     * @returns Promise
     */
    deploy({ filePath, environmentName, stack, beanstalkConfig: config, versionLabel, applicationName, tags, tier = 'WebServer', }) {
        return __awaiter(this, void 0, void 0, function* () {
            // Upload artifact
            versionLabel = yield this.archive.upload({
                filePath,
                versionLabel,
                applicationName,
            });
            // Get environment status
            const env = yield this.environment.describeEnvironment(environmentName);
            // If environment does not exist, create a new environment
            // Otherwise, update environment with new version
            if (env) {
                debug(`Deploying ${versionLabel} to ${environmentName}...`);
                yield this.environment.deploy({
                    versionLabel,
                    environmentName,
                    config,
                });
                yield this.environment.waitUntil({
                    environmentName,
                    statusCheck(desc) {
                        return !!desc && desc.Status !== 'Updating';
                    },
                });
            }
            else {
                debug(`Create stack ${stack} for ${applicationName} - ${versionLabel}`);
                yield this.environment.create({
                    applicationName,
                    environmentName,
                    versionLabel,
                    stack,
                    config,
                    tags,
                    tier,
                });
                yield this.environment.waitUntil({
                    environmentName,
                    statusCheck(desc) {
                        return !!desc && desc.Status !== 'Launching';
                    },
                });
            }
            // Wait until environment is ready or timeout
            return this.environment.waitUntil({
                environmentName,
                timeout: 300 * 1000,
                statusCheck(desc) {
                    return (!!desc && desc.Health === 'Green' && desc.Status === 'Ready');
                },
            });
        });
    }
    terminateEnvironment(args) {
        return this.environment.terminate(args);
    }
    cleanApplicationVersions(applicationName) {
        return __awaiter(this, void 0, void 0, function* () {
            const allApplicationVersions = yield this.getApplicationVersions(applicationName);
            const allEnvironments = yield this.getEnvironments(applicationName);
            const applicationVersionsInUsed = allEnvironments.map(({ VersionLabel }) => VersionLabel);
            const applicationVersionToDelete = lodash_1.difference(allApplicationVersions, applicationVersionsInUsed);
            for (const version of applicationVersionToDelete) {
                if (!version) {
                    continue;
                }
                yield wait_promise_1.sleep(1000);
                debug(`Deleting version ${version}`);
                yield this.deleteApplicationVersion({
                    version,
                    applicationName,
                });
            }
        });
    }
    cleanEnvironments(appName, appEnv) {
        return __awaiter(this, void 0, void 0, function* () {
            const defaultEnvironmentName = yield this.getDefaultEnvironment(appName, appEnv);
            const allEnvironments = yield this.getEnvironmentsForEnv(appName, appEnv);
            for (const environment of allEnvironments) {
                if (!environment.EnvironmentName ||
                    environment.EnvironmentName === defaultEnvironmentName) {
                    continue;
                }
                yield this.terminateEnvironment({
                    environmentName: environment.EnvironmentName,
                    forceTerminate: true,
                });
                yield wait_promise_1.sleep(1000);
            }
        });
    }
    getEnvironments(applicationName) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.elasticbeanstalk
                .describeEnvironments({
                ApplicationName: applicationName,
                IncludeDeleted: false,
            })
                .promise();
            return result.Environments || [];
        });
    }
    getApplicationVersions(applicationName) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.elasticbeanstalk
                .describeApplicationVersions({
                ApplicationName: applicationName,
            })
                .promise();
            return (result.ApplicationVersions || []).map(({ VersionLabel }) => VersionLabel);
        });
    }
    deleteApplication(applicationName, terminateEnvByForce = false) {
        debug(`Deleting application ${applicationName} ${terminateEnvByForce ? 'by force' : ''}`);
        return this.elasticbeanstalk
            .deleteApplication({
            ApplicationName: applicationName,
            TerminateEnvByForce: terminateEnvByForce,
        })
            .promise();
    }
    getDefaultEnvironment(appName, appEnv) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            debug(`Get default environment for app ${appName}, env: ${appEnv}`);
            const defaultEnvName = Application.getDefaultEnvironmentName(appName, appEnv);
            const relevantEnvironments = yield this.getEnvironmentsForEnv(appName, appEnv);
            return (_a = relevantEnvironments.find(relevantEnvironment => { var _a; return (_a = relevantEnvironment.CNAME) === null || _a === void 0 ? void 0 : _a.startsWith(`${defaultEnvName}.`); })) === null || _a === void 0 ? void 0 : _a.EnvironmentName;
        });
    }
    getEnvironmentsForEnv(appName, appEnv) {
        return __awaiter(this, void 0, void 0, function* () {
            const environments = yield this.getEnvironments(appName);
            return environments.filter(environment => { var _a; return (_a = environment.EnvironmentName) === null || _a === void 0 ? void 0 : _a.includes(Application.getDefaultEnvironmentName(appName, appEnv)); });
        });
    }
    getSolutionStack(platform) {
        return __awaiter(this, void 0, void 0, function* () {
            const solutionStacks = yield this.elasticbeanstalk
                .listAvailableSolutionStacks()
                .promise();
            return (solutionStacks.SolutionStacks || []).filter(current => current.toLowerCase().includes(platform.toLowerCase()));
        });
    }
    static getDefaultEnvironmentName(appName, appEnv) {
        return `${appName}-${appEnv}`;
    }
    createStorageLocation() {
        return this.elasticbeanstalk.createStorageLocation().promise();
    }
    createApplicationVersion({ applicationName, bucket, versionLabel, key, }) {
        return this.elasticbeanstalk
            .createApplicationVersion({
            ApplicationName: applicationName,
            VersionLabel: versionLabel,
            SourceBundle: {
                S3Bucket: bucket,
                S3Key: key,
            },
            AutoCreateApplication: true,
        })
            .promise();
    }
    deleteApplicationVersion({ applicationName, version, }) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.elasticbeanstalk
                .deleteApplicationVersion({
                DeleteSourceBundle: true,
                ApplicationName: applicationName,
                VersionLabel: version,
            })
                .promise();
        });
    }
    swapEnvironmentCNAMEs({ fromEnv, toEnv, }) {
        return __awaiter(this, void 0, void 0, function* () {
            debug(`Swap CNAME from ${fromEnv} to ${toEnv}`);
            yield this.elasticbeanstalk
                .swapEnvironmentCNAMEs({
                DestinationEnvironmentName: toEnv,
                SourceEnvironmentName: fromEnv,
            })
                .promise();
        });
    }
}
exports.Application = Application;
//# sourceMappingURL=application.js.map