"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const wait_promise_1 = require("wait-promise");
const POLL_INTERVAL = 5000;
const DEFAULT_STATUS_TIMEOUT = 1200 * 1000;
const debug = require('debug')('eb:application');
class Environment {
    constructor(elasticbeanstalk) {
        this.elasticbeanstalk = elasticbeanstalk;
    }
    describeEnvironment(environmentName) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.elasticbeanstalk
                .describeEnvironments({
                EnvironmentNames: [environmentName],
                IncludeDeleted: false,
            })
                .promise();
            return (result.Environments || [])[0];
        });
    }
    getEnvironment(environmentName) {
        return __awaiter(this, void 0, void 0, function* () {
            const environmentDesc = yield this.describeEnvironment(environmentName);
            if (!environmentDesc) {
                throw new Error(`Environment ${environmentName} not found`);
            }
            return environmentDesc;
        });
    }
    status(environmentName) {
        return __awaiter(this, void 0, void 0, function* () {
            const environmentDesc = yield this.getEnvironment(environmentName);
            return environmentDesc.Status;
        });
    }
    deploy({ versionLabel, environmentName, config, }) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.elasticbeanstalk
                .updateEnvironment({
                EnvironmentName: environmentName,
                OptionSettings: config,
                VersionLabel: versionLabel,
            })
                .promise();
        });
    }
    waitUntil({ environmentName, statusCheck, timeout = DEFAULT_STATUS_TIMEOUT, }) {
        return __awaiter(this, void 0, void 0, function* () {
            debug(`Checking status for environment ${environmentName}`);
            let environmentDescription = yield this.getEnvironment(environmentName);
            const currentStatus = environmentDescription.Status;
            debug(`Current status of environment ${environmentName} is ${currentStatus}`);
            const start = Date.now();
            let elapsed = 0;
            while (elapsed <= timeout && !statusCheck(environmentDescription)) {
                process.stdout.write('.');
                environmentDescription = yield this.getEnvironment(environmentName);
                elapsed = Date.now() - start;
                yield wait_promise_1.sleep(POLL_INTERVAL);
            }
            console.log();
            if (statusCheck(environmentDescription)) {
                return environmentDescription;
            }
            throw new Error(`Environment ${environmentName} failed status check`);
        });
    }
    create({ applicationName, environmentName, versionLabel, config, stack, tags = [], tier = 'WebServer', }) {
        return __awaiter(this, void 0, void 0, function* () {
            debug(`Creating environment ${environmentName}`);
            const available = yield this.checkDNSAvailability(environmentName);
            if (!available) {
                throw new Error(`DNS ${environmentName} is not available`);
            }
            yield this.elasticbeanstalk
                .createEnvironment({
                EnvironmentName: environmentName,
                ApplicationName: applicationName,
                SolutionStackName: stack,
                Tags: tags,
                Tier: {
                    Name: tier,
                    Type: tier === 'WebServer' ? 'Standard' : 'SQS/HTTP',
                },
                OptionSettings: config,
                CNAMEPrefix: environmentName,
                VersionLabel: versionLabel,
            })
                .promise();
        });
    }
    terminate({ environmentName, forceTerminate, }) {
        return __awaiter(this, void 0, void 0, function* () {
            debug(`Terminating environment ${environmentName}`);
            yield this.elasticbeanstalk
                .terminateEnvironment({
                EnvironmentName: environmentName,
                ForceTerminate: forceTerminate,
            })
                .promise();
        });
    }
    checkDNSAvailability(environmentName) {
        debug(`Check ${environmentName} availability`);
        return this.elasticbeanstalk
            .checkDNSAvailability({
            CNAMEPrefix: environmentName,
        })
            .promise()
            .then(data => data.Available);
    }
}
exports.Environment = Environment;
//# sourceMappingURL=environment.js.map